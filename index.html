<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Trout Home Range Editor</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #f0ece0;
    font-family: Georgia, serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 12px;
  }
  h1 {
    font-size: 1rem;
    font-style: italic;
    color: #3a2a10;
    margin-bottom: 8px;
    letter-spacing: 0.05em;
  }
  #controls {
    display: flex; gap: 8px; flex-wrap: wrap; justify-content: center;
    margin-bottom: 8px; align-items: center;
  }
  .btn {
    padding: 4px 12px;
    background: #e8dfc8;
    border: 1px solid #8a7a5a;
    color: #3a2a10;
    cursor: pointer;
    font-family: Georgia, serif;
    font-size: 0.72rem;
    border-radius: 2px;
    transition: all 0.15s;
  }
  .btn:hover { background: #d8cfa8; }
  .btn.active { background: #c8b880; border-color: #5a4a20; font-weight: bold; }
  .fish-selector { display: flex; gap: 5px; }
  .fish-btn {
    width: 28px; height: 28px; border-radius: 50%;
    border: 2px solid #8a7a5a;
    cursor: pointer; font-size: 0.65rem;
    font-family: Georgia, serif; font-weight: bold; color: #fff;
    transition: all 0.2s;
  }
  .fish-btn.selected { border-color: #2a1a00; transform: scale(1.25); box-shadow: 0 0 0 2px #fff; }
  #canvas-wrapper {
    border: 1px solid #8a7a5a;
    box-shadow: 3px 3px 12px rgba(0,0,0,0.25);
    background: #f5f0e0;
  }
  canvas { display: block; }
  #info {
    margin-top: 8px; font-size: 0.68rem; color: #5a4a30;
    font-style: italic; text-align: center;
  }
  #mode-label { font-size: 0.75rem; color: #5a3a10; font-weight: bold; font-family: Georgia; }
  #canvas-wrapper { position: relative; }
  #legend {
    position: absolute;
    top: 10px; left: 10px;
    background: rgba(248,240,218,0.92);
    border: 1px solid #8a7a5a;
    padding: 8px 10px 10px 10px;
    width: 148px;
    cursor: grab;
    user-select: none;
    box-shadow: 2px 2px 6px rgba(0,0,0,0.18);
    font-family: Georgia, serif;
    z-index: 10;
  }
  #legend:active { cursor: grabbing; }
  #legend-title { font-size: 9px; font-weight: bold; color: #3a2a10; margin-bottom: 4px; letter-spacing: 0.04em; }
  #legend-subtitle { font-size: 8px; color: #5a4a30; margin-bottom: 2px; }
  .legend-fish { display: flex; align-items: center; gap: 7px; font-size: 9px; color: #3a2a10; margin-top: 4px; }
  .legend-fish.selected { font-weight: bold; }
  .legend-swatch { width: 12px; height: 12px; border-radius: 50%; flex-shrink: 0; border: 1.5px solid transparent; }
  .legend-fish.selected .legend-swatch { border-color: #3a2a10; }
  #legend-flow { font-size: 9px; font-style: italic; color: #3a6a8a; margin-top: 6px; }
</style>
</head>
<body>
<h1>Trout Movement &amp; Home Range ‚Äî Interactive Editor</h1>
<div id="controls">
  <span id="mode-label">ADD POINT</span>
  <div class="fish-selector" id="fish-selector"></div>
  <button class="btn active" id="btn-add" onclick="setMode('add')">Add Point</button>
  <button class="btn" id="btn-move" onclick="setMode('move')">Move Point</button>
  <button class="btn" id="btn-delete" onclick="setMode('delete')">Delete Point</button>
  <button class="btn active" id="btn-voronoi" onclick="toggleVoronoi()">Territories</button>
  <button class="btn active" id="btn-hull" onclick="toggleHull()">Home Range</button>
  <button class="btn" onclick="resetFish()">Reset Fish</button>
  <button class="btn" onclick="exportData()">Export JSON</button>
</div>
<div id="canvas-wrapper">
  <canvas id="c"></canvas>
  <div id="legend">
    <div id="legend-title">TROUT HOME RANGES</div>
    <div id="legend-subtitle">‚óè Points &nbsp;‚Äî Connections</div>
    <div id="legend-subtitle">‚ïå Convex Hull &nbsp;‚ñë Territory</div>
    <div id="legend-fish-list"></div>
    <div id="legend-flow">‚Üì current flow</div>
  </div>
</div>
<div id="info">Click to add points to selected fish's home range cloud ¬∑ Move mode: drag points ¬∑ Lines connect all points within each cloud</div>

<script>
const W = 760, H = 900;
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
canvas.width = W; canvas.height = H;

// Fish species colors ‚Äî warm naturalistic palette
const FISH = [
  { name: 'Trout 1', main: '#b8460a', light: '#e8905a', label: 'T1' },
  { name: 'Trout 2', main: '#2a7a3a', light: '#70c080', label: 'T2' },
  { name: 'Trout 3', main: '#1a5a9a', light: '#60a0d0', label: 'T3' },
  { name: 'Trout 4', main: '#8a3a8a', light: '#c07ac0', label: 'T4' },
  { name: 'Trout 5', main: '#7a6a10', light: '#c0a840', label: 'T5' },
];

// Stream centerline control points (diagonal, meandering top-left ‚Üí bottom-right)
const STREAM_CL = [
  {x:80,  y:30},
  {x:160, y:80},
  {x:200, y:160},
  {x:170, y:250},
  {x:200, y:330},
  {x:260, y:390},
  {x:330, y:430},
  {x:380, y:510},
  {x:360, y:600},
  {x:390, y:670},
  {x:450, y:720},
  {x:530, y:760},
  {x:600, y:820},
  {x:660, y:880},
];

// Stream width varies along path
const STREAM_W = [38, 42, 48, 44, 46, 52, 56, 50, 48, 52, 58, 60, 56, 52];

// 5 fish home range clouds, distributed along stream (roughly at positions 1-2, 3, 5, 7-8, 10-11)
// Each fish cluster will be centered near the stream at those positions
let fishClouds = [[], [], [], [], []];

function catmullRomPoint(pts, t) {
  // t in [0, pts.length-1]
  const n = pts.length;
  const i = Math.min(Math.floor(t), n - 2);
  const u = t - i;
  const p0 = pts[Math.max(i - 1, 0)];
  const p1 = pts[i];
  const p2 = pts[Math.min(i + 1, n - 1)];
  const p3 = pts[Math.min(i + 2, n - 1)];
  return {
    x: 0.5*((2*p1.x)+(-p0.x+p2.x)*u+(2*p0.x-5*p1.x+4*p2.x-p3.x)*u*u+(-p0.x+3*p1.x-3*p2.x+p3.x)*u*u*u),
    y: 0.5*((2*p1.y)+(-p0.y+p2.y)*u+(2*p0.y-5*p1.y+4*p2.y-p3.y)*u*u+(-p0.y+3*p1.y-3*p2.y+p3.y)*u*u*u),
  };
}

// Get stream width at parameter t
function streamWidthAt(t) {
  const n = STREAM_W.length;
  const i = Math.min(Math.floor(t), n - 2);
  const u = t - i;
  return STREAM_W[i] * (1 - u) + STREAM_W[Math.min(i+1,n-1)] * u;
}

// Build sampled stream path
function buildStreamSamples(steps = 200) {
  const pts = [];
  for (let i = 0; i <= steps; i++) {
    const t = i / steps * (STREAM_CL.length - 1);
    pts.push({ pt: catmullRomPoint(STREAM_CL, t), t: t });
  }
  return pts;
}
const STREAM_SAMPLES = buildStreamSamples();

// Get perpendicular normal at sample index
function getNormal(samples, idx) {
  const a = samples[Math.max(idx-1,0)].pt;
  const b = samples[Math.min(idx+1,samples.length-1)].pt;
  const dx = b.x - a.x, dy = b.y - a.y;
  const len = Math.sqrt(dx*dx+dy*dy) || 1;
  return { nx: -dy/len, ny: dx/len };
}

// Generate home range cloud for fish i centered at parameter t along stream
function generateCloud(streamT, numPts=25) {
  const cIdx = Math.round(streamT / (STREAM_CL.length - 1) * (STREAM_SAMPLES.length - 1));
  const center = STREAM_SAMPLES[Math.min(cIdx, STREAM_SAMPLES.length-1)].pt;
  const sw = streamWidthAt(streamT);
  const pts = [];
  // Spread: mostly along stream (longitudinal), less across
  for (let i = 0; i < numPts; i++) {
    const angle = Math.random() * Math.PI * 2;
    const rLong = (0.3 + Math.random() * 0.7) * sw * 2.5; // along stream
    const rCross = (0.1 + Math.random() * 0.9) * sw * 0.85; // across stream
    // Get stream tangent direction
    const norm = getNormal(STREAM_SAMPLES, Math.min(cIdx, STREAM_SAMPLES.length-1));
    // tangent perpendicular to normal
    const tx = norm.ny, ty = -norm.nx;
    const nx = norm.nx, ny = norm.ny;
    pts.push({
      x: Math.round(center.x + tx * (Math.random()-0.5) * rLong * 2 + nx * (Math.random()-0.5) * rCross * 2),
      y: Math.round(center.y + ty * (Math.random()-0.5) * rLong * 2 + ny * (Math.random()-0.5) * rCross * 2),
    });
  }
  return pts;
}

// Fish cloud center positions along stream (parameter t values, 0 = top, 12 = bottom)
const FISH_T = [1.2, 3.2, 5.4, 7.8, 10.5];
function initClouds() {
  for (let i = 0; i < 5; i++) {
    fishClouds[i] = generateCloud(FISH_T[i], 24);
  }
}
initClouds();

// Build fish selector buttons
const sel = document.getElementById('fish-selector');
FISH.forEach((f, i) => {
  const btn = document.createElement('button');
  btn.className = 'fish-btn' + (i===0?' selected':'');
  btn.style.background = f.main;
  btn.title = f.name;
  btn.textContent = i+1;
  btn.onclick = () => selectFish(i);
  sel.appendChild(btn);
});

let selectedFish = 0;
let mode = 'add';
let showVoronoi = true;
let showHull = true;
let dragging = null;

function selectFish(i) {
  selectedFish = i;
  document.querySelectorAll('.fish-btn').forEach((b,idx) => b.classList.toggle('selected', idx===i));
  render();
}

function setMode(m) {
  mode = m;
  ['add','move','delete'].forEach(mm => {
    const b = document.getElementById('btn-'+mm);
    if(b) b.classList.toggle('active', mm===m);
  });
  document.getElementById('mode-label').textContent = m === 'add' ? 'ADD POINT' : m === 'move' ? 'MOVE POINT' : 'DELETE POINT';
  canvas.style.cursor = m==='delete'?'not-allowed': m==='move'?'grab':'crosshair';
}

function toggleVoronoi() {
  showVoronoi = !showVoronoi;
  document.getElementById('btn-voronoi').classList.toggle('active', showVoronoi);
  voronoiDirty = true;
  render();
}
function toggleHull() {
  showHull = !showHull;
  document.getElementById('btn-hull').classList.toggle('active', showHull);
  render();
}
function resetFish() {
  if (confirm(`Reset ${FISH[selectedFish].name}?`)) {
    fishClouds[selectedFish] = generateCloud(FISH_T[selectedFish], 24);
    voronoiDirty = true;
    render();
  }
}

// ---------- DRAWING ----------

// Parchment / map background
function drawBackground() {
  const g = ctx.createLinearGradient(0,0,W,H);
  g.addColorStop(0, '#f5f0e0');
  g.addColorStop(0.5, '#ede5c8');
  g.addColorStop(1, '#e8e0c8');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  // Grain texture
  ctx.globalAlpha = 0.04;
  for (let i = 0; i < 3000; i++) {
    ctx.fillStyle = Math.random() > 0.5 ? '#8a7a50' : '#fff';
    ctx.fillRect(Math.random()*W, Math.random()*H, 1, 1);
  }
  ctx.globalAlpha = 1;
}

// Draw vegetation circles (trees/shrubs like reference image)
function drawVegetation() {
  const rng = (seed) => {
    let s = seed;
    return () => { s = (s * 1664525 + 1013904223) & 0xffffffff; return (s >>> 0) / 0xffffffff; };
  };
  const r = rng(42);

  // Scatter vegetation along both banks
  const bankPts = [];
  for (let s = 0; s < STREAM_SAMPLES.length; s += 6) {
    const samp = STREAM_SAMPLES[s];
    const norm = getNormal(STREAM_SAMPLES, s);
    const sw = streamWidthAt(samp.t) + 10;
    // Left bank
    bankPts.push({
      x: samp.pt.x + norm.nx * (sw + r()*25 + 15),
      y: samp.pt.y + norm.ny * (sw + r()*25 + 15),
      side: -1
    });
    // Right bank
    bankPts.push({
      x: samp.pt.x - norm.nx * (sw + r()*25 + 15),
      y: samp.pt.y - norm.ny * (sw + r()*25 + 15),
      side: 1
    });
  }

  // Draw shrubs
  bankPts.forEach((bp, i) => {
    const seed2 = i * 137;
    const radius = 14 + (seed2 % 12);
    const x = bp.x + ((seed2 * 3) % 20) - 10;
    const y = bp.y + ((seed2 * 7) % 20) - 10;
    if (x < -20 || x > W+20 || y < -20 || y > H+20) return;

    // Shadow
    ctx.beginPath();
    ctx.ellipse(x+3, y+3, radius*1.1, radius*0.8, 0, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(0,0,0,0.08)';
    ctx.fill();

    // Shrub body
    const shrubG = ctx.createRadialGradient(x-2, y-2, 1, x, y, radius);
    shrubG.addColorStop(0, '#8ac870');
    shrubG.addColorStop(0.6, '#5a9040');
    shrubG.addColorStop(1, '#3a6820');
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI*2);
    ctx.fillStyle = shrubG;
    ctx.fill();

    // Highlight
    ctx.beginPath();
    ctx.arc(x-3, y-3, radius*0.4, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(180,230,130,0.35)';
    ctx.fill();
  });
}

// Draw the stream (water channel + banks + gravel bars)
function drawStream() {
  const N = STREAM_SAMPLES.length;

  // Outer bank (land/gravel color)
  ctx.beginPath();
  // Left edge
  for (let i = 0; i < N; i++) {
    const s = STREAM_SAMPLES[i];
    const norm = getNormal(STREAM_SAMPLES, i);
    const sw = streamWidthAt(s.t) + 22;
    const x = s.pt.x + norm.nx * sw;
    const y = s.pt.y + norm.ny * sw;
    i===0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
  }
  // Right edge (reverse)
  for (let i = N-1; i >= 0; i--) {
    const s = STREAM_SAMPLES[i];
    const norm = getNormal(STREAM_SAMPLES, i);
    const sw = streamWidthAt(s.t) + 22;
    ctx.lineTo(s.pt.x - norm.nx*sw, s.pt.y - norm.ny*sw);
  }
  ctx.closePath();
  ctx.fillStyle = '#d8c89a';
  ctx.fill();

  // Gravel bar (inner sandy area)
  ctx.beginPath();
  for (let i = 0; i < N; i++) {
    const s = STREAM_SAMPLES[i];
    const norm = getNormal(STREAM_SAMPLES, i);
    const sw = streamWidthAt(s.t) + 8;
    const x = s.pt.x + norm.nx * sw;
    const y = s.pt.y + norm.ny * sw;
    i===0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
  }
  for (let i = N-1; i >= 0; i--) {
    const s = STREAM_SAMPLES[i];
    const norm = getNormal(STREAM_SAMPLES, i);
    const sw = streamWidthAt(s.t) + 8;
    ctx.lineTo(s.pt.x - norm.nx*sw, s.pt.y - norm.ny*sw);
  }
  ctx.closePath();
  ctx.fillStyle = '#e8d8a8';
  ctx.fill();

  // Water channel
  ctx.beginPath();
  for (let i = 0; i < N; i++) {
    const s = STREAM_SAMPLES[i];
    const norm = getNormal(STREAM_SAMPLES, i);
    const sw = streamWidthAt(s.t);
    const x = s.pt.x + norm.nx * sw;
    const y = s.pt.y + norm.ny * sw;
    i===0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
  }
  for (let i = N-1; i >= 0; i--) {
    const s = STREAM_SAMPLES[i];
    const norm = getNormal(STREAM_SAMPLES, i);
    const sw = streamWidthAt(s.t);
    ctx.lineTo(s.pt.x - norm.nx*sw, s.pt.y - norm.ny*sw);
  }
  ctx.closePath();

  // Water gradient - blue-green naturalistic
  const waterG = ctx.createLinearGradient(0,0,W,H);
  waterG.addColorStop(0, '#aad4e8');
  waterG.addColorStop(0.4, '#7ab8d0');
  waterG.addColorStop(1, '#5a9ab8');
  ctx.fillStyle = waterG;
  ctx.fill();

  // Water ripple lines
  ctx.save();
  ctx.clip();
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 0.7;
  for (let i = 0; i < N; i += 8) {
    const s = STREAM_SAMPLES[i];
    const norm = getNormal(STREAM_SAMPLES, i);
    const sw = streamWidthAt(s.t) - 6;
    if (sw < 4) continue;
    ctx.beginPath();
    ctx.moveTo(s.pt.x + norm.nx*sw*0.5, s.pt.y + norm.ny*sw*0.5);
    ctx.lineTo(s.pt.x - norm.nx*sw*0.5, s.pt.y - norm.ny*sw*0.5);
    ctx.stroke();
  }
  ctx.restore();

  // Bank edge lines
  ctx.beginPath();
  for (let i = 0; i < N; i++) {
    const s = STREAM_SAMPLES[i];
    const norm = getNormal(STREAM_SAMPLES, i);
    const sw = streamWidthAt(s.t);
    const x = s.pt.x + norm.nx * sw;
    const y = s.pt.y + norm.ny * sw;
    i===0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
  }
  ctx.strokeStyle = '#7a9a7a';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  ctx.beginPath();
  for (let i = 0; i < N; i++) {
    const s = STREAM_SAMPLES[i];
    const norm = getNormal(STREAM_SAMPLES, i);
    const sw = streamWidthAt(s.t);
    i===0 ? ctx.moveTo(s.pt.x - norm.nx*sw, s.pt.y - norm.ny*sw) : ctx.lineTo(s.pt.x - norm.nx*sw, s.pt.y - norm.ny*sw);
  }
  ctx.strokeStyle = '#7a9a7a';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Flow arrow
  for (let s = 20; s < N-10; s += 30) {
    const samp = STREAM_SAMPLES[s];
    const samp2 = STREAM_SAMPLES[Math.min(s+8, N-1)];
    const dx = samp2.pt.x - samp.pt.x;
    const dy = samp2.pt.y - samp.pt.y;
    const len = Math.sqrt(dx*dx+dy*dy);
    if (len < 1) continue;
    const nx2 = dx/len, ny2 = dy/len;
    const ax = samp.pt.x, ay = samp.pt.y;
    ctx.beginPath();
    ctx.moveTo(ax, ay);
    ctx.lineTo(ax + nx2*12, ay + ny2*12);
    ctx.strokeStyle = 'rgba(255,255,255,0.45)';
    ctx.lineWidth = 1.2;
    ctx.stroke();
    // arrowhead
    ctx.beginPath();
    ctx.moveTo(ax + nx2*12, ay + ny2*12);
    ctx.lineTo(ax + nx2*8 - ny2*4, ay + ny2*8 + nx2*4);
    ctx.moveTo(ax + nx2*12, ay + ny2*12);
    ctx.lineTo(ax + nx2*8 + ny2*4, ay + ny2*8 - nx2*4);
    ctx.stroke();
  }
}

// Convex hull (Graham scan)
function convexHull(pts) {
  if (pts.length < 3) return pts.slice();
  const sorted = pts.slice().sort((a,b) => a.x-b.x || a.y-b.y);
  const cross = (o,a,b) => (a.x-o.x)*(b.y-o.y)-(a.y-o.y)*(b.x-o.x);
  const lower = [], upper = [];
  for (const p of sorted) {
    while (lower.length >= 2 && cross(lower[lower.length-2], lower[lower.length-1], p) <= 0) lower.pop();
    lower.push(p);
  }
  for (let i = sorted.length-1; i >= 0; i--) {
    const p = sorted[i];
    while (upper.length >= 2 && cross(upper[upper.length-2], upper[upper.length-1], p) <= 0) upper.pop();
    upper.push(p);
  }
  upper.pop(); lower.pop();
  return lower.concat(upper);
}

// Voronoi
let voronoiCache = null, voronoiDirty = true;
function computeVoronoi() {
  const allPoints = [];
  fishClouds.forEach((pts, fi) => pts.forEach(p => allPoints.push({x:p.x,y:p.y,fi})));
  if (!allPoints.length) return null;
  const scale = 5;
  const w2 = Math.ceil(W/scale), h2 = Math.ceil(H/scale);
  const img = new Uint8Array(w2*h2);
  for (let py = 0; py < h2; py++) {
    for (let px = 0; px < w2; px++) {
      const rx = px*scale+scale/2, ry = py*scale+scale/2;
      let bd = Infinity, bfi = 0;
      for (const p of allPoints) {
        const d = (rx-p.x)**2+(ry-p.y)**2;
        if (d < bd) { bd=d; bfi=p.fi; }
      }
      img[py*w2+px] = bfi;
    }
  }
  return {img, w:w2, h:h2, scale};
}

function drawVoronoi(vor) {
  if (!vor) return;
  const {img, w, h, scale} = vor;
  for (let py = 0; py < h; py++) {
    for (let px = 0; px < w; px++) {
      const fi = img[py*w+px];
      let boundary = false;
      if (px>0 && img[py*w+px-1]!==fi) boundary=true;
      else if (px<w-1 && img[py*w+px+1]!==fi) boundary=true;
      else if (py>0 && img[(py-1)*w+px]!==fi) boundary=true;
      else if (py<h-1 && img[(py+1)*w+px]!==fi) boundary=true;
      if (boundary) {
        ctx.fillStyle = 'rgba(80,60,30,0.22)';
        ctx.fillRect(px*scale, py*scale, scale, scale);
      } else {
        const c = FISH[fi].main;
        const r = parseInt(c.slice(1,3),16), g = parseInt(c.slice(3,5),16), b = parseInt(c.slice(5,7),16);
        ctx.fillStyle = `rgba(${r},${g},${b},0.07)`;
        ctx.fillRect(px*scale, py*scale, scale, scale);
      }
    }
  }
}

// Draw home range hull (convex hull with soft fill)
function drawHull(pts, color) {
  if (pts.length < 3) return;
  const hull = convexHull(pts);
  if (hull.length < 3) return;
  ctx.beginPath();
  ctx.moveTo(hull[0].x, hull[0].y);
  for (let i = 1; i < hull.length; i++) ctx.lineTo(hull[i].x, hull[i].y);
  ctx.closePath();
  const r = parseInt(color.slice(1,3),16), g = parseInt(color.slice(3,5),16), b = parseInt(color.slice(5,7),16);
  ctx.fillStyle = `rgba(${r},${g},${b},0.12)`;
  ctx.fill();
  ctx.strokeStyle = `rgba(${r},${g},${b},0.5)`;
  ctx.lineWidth = 1.2;
  ctx.setLineDash([4,3]);
  ctx.stroke();
  ctx.setLineDash([]);
}

// Draw connection lines + points for a cloud
function drawCloud(pts, fi, isSelected) {
  if (pts.length === 0) return;
  const fc = FISH[fi];

  // Lines connecting points (all-to-all for nearby pts, or sequential + cross)
  // Use Delaunay-ish: connect each point to its N nearest neighbors
  const K = 3; // connect each to 3 nearest
  const pairs = new Set();
  pts.forEach((p, i) => {
    const dists = pts.map((q, j) => ({j, d: (p.x-q.x)**2+(p.y-q.y)**2}))
      .filter(x => x.j !== i)
      .sort((a,b) => a.d - b.d)
      .slice(0, K);
    dists.forEach(({j}) => {
      const key = i < j ? `${i}-${j}` : `${j}-${i}`;
      pairs.add(key + ':' + i + ':' + j);
    });
  });

  // Draw lines
  pairs.forEach(entry => {
    const parts = entry.split(':');
    const i = parseInt(parts[1]), j = parseInt(parts[2]);
    const p = pts[i], q = pts[j];
    ctx.beginPath();
    ctx.moveTo(p.x, p.y);
    ctx.lineTo(q.x, q.y);
    const dist = Math.sqrt((p.x-q.x)**2+(p.y-q.y)**2);
    const alpha = isSelected ? 0.5 : 0.3;
    ctx.strokeStyle = fc.main + Math.round(alpha*255).toString(16).padStart(2,'0');
    ctx.lineWidth = isSelected ? 1.2 : 0.8;
    ctx.stroke();
  });

  // Points
  pts.forEach((p, idx) => {
    const r = isSelected ? 5.5 : 4;
    // Shadow
    ctx.beginPath();
    ctx.arc(p.x+1, p.y+1, r, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fill();
    // Fill
    ctx.beginPath();
    ctx.arc(p.x, p.y, r, 0, Math.PI*2);
    ctx.fillStyle = isSelected ? fc.light : fc.main + 'cc';
    ctx.fill();
    ctx.strokeStyle = isSelected ? '#fff' : fc.light + '99';
    ctx.lineWidth = isSelected ? 1.5 : 0.8;
    ctx.stroke();
    // Point index for selected
    if (isSelected) {
      ctx.fillStyle = 'rgba(0,0,0,0.65)';
      ctx.font = '8px Georgia';
      ctx.fillText(idx+1, p.x+6, p.y+3);
    }
  });

  // Fish symbol at centroid
  if (pts.length > 0) {
    const cx = pts.reduce((s,p) => s+p.x,0)/pts.length;
    const cy = pts.reduce((s,p) => s+p.y,0)/pts.length;
    ctx.font = isSelected ? 'bold 11px Georgia' : '10px Georgia';
    ctx.fillStyle = fc.main;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 3;
    ctx.strokeText(fc.name, cx+8, cy-6);
    ctx.fillText(fc.name, cx+8, cy-6);
    // Fish icon
    ctx.font = '16px serif';
    ctx.fillText('üêü', cx-8, cy+6);
  }
}

// Legend box (HTML overlay)
function drawLegend() {
  const list = document.getElementById('legend-fish-list');
  list.innerHTML = FISH.map((f, i) => `
    <div class="legend-fish${i===selectedFish?' selected':''}">
      <div class="legend-swatch" style="background:${f.main}"></div>
      ${f.name}
    </div>`).join('');
}

function render() {
  ctx.clearRect(0,0,W,H);
  drawBackground();
  drawVegetation();
  drawStream();

  if (showVoronoi) {
    if (voronoiDirty) { voronoiCache = computeVoronoi(); voronoiDirty = false; }
    drawVoronoi(voronoiCache);
  }

  // Draw non-selected fish first
  for (let i = 0; i < 5; i++) {
    if (i === selectedFish) continue;
    if (showHull) drawHull(fishClouds[i], FISH[i].main);
    drawCloud(fishClouds[i], i, false);
  }
  // Draw selected on top
  if (showHull) drawHull(fishClouds[selectedFish], FISH[selectedFish].main);
  drawCloud(fishClouds[selectedFish], selectedFish, true);

  drawLegend();
}

// --- Interaction ---
function getPos(e) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: (e.clientX - rect.left) * W / rect.width,
    y: (e.clientY - rect.top) * H / rect.height
  };
}

function findNearest(x, y, thresh=12) {
  let best=null, bd=thresh*thresh;
  fishClouds.forEach((pts, fi) => {
    pts.forEach((p, idx) => {
      const d=(p.x-x)**2+(p.y-y)**2;
      if(d<bd){bd=d;best={fi,idx};}
    });
  });
  return best;
}

canvas.addEventListener('mousedown', e => {
  const {x,y} = getPos(e);
  if (mode==='add') {
    fishClouds[selectedFish].push({x:Math.round(x),y:Math.round(y)});
    voronoiDirty=true; render();
  } else if (mode==='move') {
    const f = findNearest(x,y);
    if (f) { dragging=f; canvas.style.cursor='grabbing'; }
  } else if (mode==='delete') {
    const f = findNearest(x,y);
    if (f) { fishClouds[f.fi].splice(f.idx,1); voronoiDirty=true; render(); }
  }
});
canvas.addEventListener('mousemove', e => {
  if (!dragging) return;
  const {x,y} = getPos(e);
  fishClouds[dragging.fi][dragging.idx] = {x:Math.round(x),y:Math.round(y)};
  voronoiDirty=true; render();
});
canvas.addEventListener('mouseup', () => {
  dragging=null;
  if(mode==='move') canvas.style.cursor='grab';
});
canvas.addEventListener('mouseleave', () => { dragging=null; });

function exportData() {
  const out = {};
  fishClouds.forEach((pts,i) => { out[FISH[i].name] = pts; });
  const blob = new Blob([JSON.stringify(out,null,2)], {type:'application/json'});
  const a = document.createElement('a');
  a.href=URL.createObjectURL(blob); a.download='trout_homeranges.json'; a.click();
}

render();

// --- Draggable legend ---
(function() {
  const leg = document.getElementById('legend');
  let ox=0, oy=0, lx=0, ly=0, down=false;
  leg.addEventListener('mousedown', e => {
    down = true;
    ox = e.clientX; oy = e.clientY;
    const style = window.getComputedStyle(leg);
    lx = parseInt(style.left)||0; ly = parseInt(style.top)||0;
    e.preventDefault();
  });
  document.addEventListener('mousemove', e => {
    if (!down) return;
    const dx = e.clientX - ox, dy = e.clientY - oy;
    const wrapper = document.getElementById('canvas-wrapper');
    const maxX = wrapper.offsetWidth - leg.offsetWidth;
    const maxY = wrapper.offsetHeight - leg.offsetHeight;
    leg.style.left = Math.max(0, Math.min(lx+dx, maxX)) + 'px';
    leg.style.top  = Math.max(0, Math.min(ly+dy, maxY)) + 'px';
  });
  document.addEventListener('mouseup', () => { down = false; });
})();
</script>
</body>
</html>
